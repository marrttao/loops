# Generated by Qodo Gen

import unittest
from main import chess_desk

class TestChessDesk(unittest.TestCase):

    # Generates a chessboard pattern with specified square size
    def test_chessboard_pattern_with_square_size(self):
        from io import StringIO
        import sys

        # Redirect stdout to capture print output
        captured_output = StringIO()
        sys.stdout = captured_output

        # Test with a square size of 3
        chess_desk(3)

        # Reset redirect.
        sys.stdout = sys.__stdout__

        expected_output = (
            '*** --- *** --- *** --- *** --- \n'
            '--- *** --- *** --- *** --- *** '
            '*** --- *** --- *** --- *** --- \n'
            '--- *** --- *** --- *** --- *** '
            '*** --- *** --- *** --- *** --- \n'
            '--- *** --- *** --- *** --- *** ')
        self.assertEqual(captured_output.getvalue(), expected_output)

    # Handles zero or negative `large_of_square` gracefully
    def test_zero_or_negative_square_size(self):
        from io import StringIO
        import sys

        # Redirect stdout to capture print output
        captured_output = StringIO()
        sys.stdout = captured_output

        # Test with a square size of 0
        chess_desk(0)

        # Reset redirect.
        sys.stdout = sys.__stdout__

        expected_output = (
            " \n"
            " \n"
            " \n"
            " \n"
            " \n"
            " \n"
        )
        self.assertEqual(captured_output.getvalue(), expected_output)

        # Test with a negative square size
        captured_output = StringIO()
        sys.stdout = captured_output

        chess_desk(-1)

        # Reset redirect.
        sys.stdout = sys.__stdout__

        self.assertEqual(captured_output.getvalue(), expected_output)

    # Manages very large values for `large_of_square` without performance issues
    def test_large_square_size_performance(self):
        import time

        start_time = time.time()

        # Test with a large square size
        chess_desk(1000)

        end_time = time.time()

        # Check if the function executes within a reasonable time frame (e.g., 1 second)
        self.assertTrue(end_time - start_time < 1, "Performance issue with large square size")